<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <script>
//        原型链的问题
//        function SuperType(){
//            this.colors=['red','green','blue']
//        }
//        function SubType(){
//            SuperType.call(this);
//        }
//        var instance1 = new SubType();
//        instance1.colors.push('black');
//        alert(instance1.colors);
//
//        var instance2=new SubType();
//        alert(instance2.colors);

//传递参数
//function SuperType(name){
//    this.name=name;
//}
//        function SubType(){
//            SuperType.call(this,'Nick');
//            this.age=29;
//        }
//        var instance=new SubType();
//        alert(instance.name);
//        alert(instance.age);

组合继承
        function SuperType(name){
            this.name=name;
            this.colors=['red','green','blue']
        }
        SuperType.prototype.sayName=function(){
            alert(this.name)
        };
        function SubType(name,age){
            SuperType.call(this.name);
            this.age=29
        }
        SuperType.prototype=new SuperType();
        SuperType.prototype.constructor=SubType;
        SuperType.prototype.sayAge=function(){
            alert(this.age)
        };
        var instance1 = new SubType('Nick',29);
        instance1.colors.push('black');
        alert(instance1.colors);
        instance1.sayName();
        instance1.sayAge();

        var instance2 = new SubType('nick',27);
        alert(instance2.colors);
        instance2.sayName();
        instance2.sayAge();

//        原型式继承
//道格拉斯·克罗克福德给出的函数
//        function Object(){
//            function F(){}
//            F.prototype=o;
//            return new F();
//        }

        var person ={
            name:'nick',
            friends:['shelby','nick','van']
        };
        var anotherPerson=object(person);
        anotherPerson.name='grey';
        anotherPerson.friends.push('robot');

        var yetAnotherPerson = object(person);
        yetAnotherPerson.name='linda';
        yetAnotherPerson.friends.push('barbie');
        alert(person.friends)

//        var person ={
//            name:'nick',
//            friends:['shelby','nick','van']
//        };
//        var anotherPerson=Object.create(person);
//        anotherPerson.name='grey';
//        anotherPerson.friends.push('robot');
//
//        var yetAnotherPerson = Object.create(person);
//        yetAnotherPerson.name='linda';
//        yetAnotherPerson.friends.push('barbie');
//        alert(person.friends)

//        var person ={
//            name:'nick',
//            friends:['shelby','nick','van']
//        };
//        var anotherPerson=Object.create(person,{
//            name:{
//                value:'nick'
//            }
//        });


        寄生式继承
        function cerateAnother(original){
            var clone=Object(original);
            clone.sayHi=function(){
                alert('hi')
            };
            return clone;
        }
        var person ={
            name:'nick',
            friends:['ha','la','gua']
        };
        var anotherPerson=cerateAnother(person);
        anotherPerson.sayHi()

        寄生组合继承
        function SuperType(name){
            this.name=name;
            this.colors=['red','blue','green']
        }
        SuperType.prototype.sayName=function(){
            alert(this.name)
        };
        function SubType(name,age){
            SuperType.call(this,name);
            this.age=age;
        }
        SubType.prototype=new SuperType();
        SubType.prototype.constructor=SubType;
        SubType.prototype.sayAge=function(){
            alert(this.age)
        };

    </script>
</body>
</html>